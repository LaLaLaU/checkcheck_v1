# CheckCheck 项目当前问题记录

**日期**: 2025-04-29
**版本**: 1.3

## 待解决问题

### 1. 文本区分策略不合理 (优先级: 高)

**问题描述**: 
当前代码简单地根据文本框Y坐标位置区分上下文本（标牌/喷码），这种方法不够灵活，无法适应不同图像布局，特别是标牌竖放时完全无法区分。

**原因分析**:
在 `_recognize_current_frame` 或 `_perform_camera_recognition` 方法中，使用了固定的Y坐标位置划分策略。

**建议解决方案**:
1. 不预先区分标牌/喷码文字，而是将所有识别到的文本列出。
2. 在UI中添加交互方式（如下拉列表、文本框、或直接在图像上点击选择），让用户手动指定哪个文本是标牌，哪个是喷码。
3. **(可选)** 探索基于文本内容特征（如关键字、格式）或相对位置关系（如哪个框在哪个框的上方/左侧）的自动区分方法。

**实施状态**: 待解决

### 2. 相机2画面显示异常 (优先级: 高)

**问题描述**: 
通过下拉框选择索引为 2 的相机后，应用主界面显示的画面为雪花状乱码（噪点），而非正常的实时视频流。此相机在其他软件（如 Windows 相机应用）中可以正常显示。

**初步分析**: 
- OpenCV 可能未能正确识别或使用相机 2 支持的视频流格式或分辨率。
- `cv2.VideoCapture` 使用的后端 API (如 DSHOW, MSMF) 可能与相机 2 的驱动存在兼容性问题。
- 尽管其他软件能用，但 OpenCV 的访问方式可能触发了驱动的某个问题。

**建议排查步骤**: 
1.  **检查日志**: 仔细查看应用运行时选择相机 2 后的详细日志，寻找 OpenCV 或 CameraWorker 相关的警告或错误信息。
2.  **尝试设置分辨率**: 在 `CameraWorker` 的 `run` 方法中，成功打开相机 (`self.cap.isOpened()`) 后，尝试使用 `self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)` 和 `self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)` (或其他常用分辨率如 640x480) 显式设置分辨率，再开始读取帧。
3.  **尝试不同后端**: 修改 `CameraWorker`，强制只使用 `cv2.CAP_MSMF` 或只使用 `cv2.CAP_DSHOW` 来打开相机 2，看是否能解决问题。
4.  **独立测试脚本**: 编写一个极简的 Python 脚本，仅使用 `cv2.VideoCapture(2)` 或 `cv2.VideoCapture(2, cv2.CAP_MSMF)` 等方式打开相机 2 并显示画面，排除应用其他部分的干扰。

**实施状态**: 待解决

## 已解决问题

### 3. 无法选择或切换相机

**问题描述**: 
当检测到多个相机时，用户无法通过UI控件选择使用哪个相机。

**解决方案**:
1. 在 `src/ui/main_window.py` 中添加了 `QComboBox` 控件。
2. 在 `_init_camera` 方法中调用 `detect_available_cameras` 获取可用相机列表并填充下拉框。
3. 实现了 `on_camera_selection_changed` 方法处理用户选择，并在相机运行时停止旧相机、启动新相机。
4. 修改了 `start_camera` 方法以使用用户选择的相机索引。
5. 调整了 UI 状态管理，确保在相机运行时允许用户切换相机。

**实施状态**: 已解决 (V1.3)

### 4. 相机识别后无法恢复实时预览

**问题描述**: 
在相机模式下点击识别后，画面暂停显示结果，但没有提供恢复实时预览的按钮。

**解决方案**: 
1. 重新在 `_setup_ui` 中添加了 `resume_camera_button`。
2. 恢复了 `resume_camera` 方法的实现。
3. 在 `_perform_camera_recognition` 识别完成、暂停画面后，启用 `resume_camera_button` 并设置 `self.pause_camera_updates = True`。
4. 确保 `update_frame` 检查 `pause_camera_updates` 标志。

**实施状态**: 已解决 (V1.3)

### 5. 上传图片识别导致应用闪退 

**问题描述**: 
上传图片后点击识别按钮会导致应用程序崩溃。

**解决方案**:
修改了 `on_start_recognition` 方法，使用正确的变量：
- 使用 `self.image_path` 而非 `self.current_image` 检查文件存在
- 使用已加载的 `self.cv_image` 进行OCR处理，而不是尝试重新加载图像

**实施状态**: 已解决

### 6. 识别记录无法保存 

**问题描述**:
识别完成后，相关结果无法保存到历史记录数据库中。

**解决方案**:
1. 实现了 `add_record` 方法调用数据库管理器
2. 创建了 `_ensure_capture_dir` 方法确保捕获图像的保存目录存在
3. 在静态图片和相机模式下都添加了记录保存代码

**实施状态**: 已解决

### 7. 识别内容显示可读性问题 (部分解决)

**问题描述**:
主页面识别内容缺乏视觉区分，需要在图像上直接标记识别到的文字区域。在相机模式下，识别后主界面仍显示实时相机画面，无法看到标记的文本框。

**解决方案**:
1. 添加了 `_draw_text_boxes` 方法，用于在图像上绘制文本框和标签
2. 在相机模式和静态图片模式下的识别过程中，都添加了绘制文本框的代码
3. 使用不同颜色区分不同类型的文本（绿色表示标牌文字，红色表示喷码文字）
4. 移除了文本标签中的序号前缀，只显示文本内容和置信度
5. 添加了暂停相机画面更新的功能 (`pause_camera_updates`)，确保在识别完成后显示带有文本框标记的抓取画面。
6. 添加了"恢复相机"按钮 (`resume_camera_button`)，允许用户在查看识别结果后恢复实时相机画面。

**实施状态**: 部分解决 (暂停/恢复机制已实现，但标记内容本身的可读性可进一步优化)

### 8. 文本区分策略不合理 -> 移至待解决

### 9. 图片识别和相机识别模式切换功能

**问题描述**: 
当前应用程序无法在图片识别和相机识别模式之间切换。

**原因分析**:
缺少实现模式切换的代码。

**解决方案**:
1. 添加了模式切换按钮 `switch_mode_button`。
2. 实现了 `switch_to_camera_mode` 和 `switch_to_image_mode` 方法。
3. 在相应场景调用这些方法来切换 UI 状态和相机启停。

**实施状态**: 已解决

### 10. 上传图像识别后切换为相机导致应用闪退

**问题描述**: 
上传图像识别后切换为相机模式导致应用闪退。

**原因分析**:
在 `switch_to_camera_mode` 方法中先停止相机再启动相机，但在上传图像识别后相机并未启动，导致 `stop_camera` 方法出错。

**解决方案**:
1. 修改 `switch_to_camera_mode` 方法，先检查相机是否已经启动。
2. 调整 `start_camera` 和 `stop_camera` 逻辑，确保状态正确管理。

**实施状态**: 已解决

### 11. UI进一步优化

**问题描述**:
1. 在点击恢复相机瞬间和上传新的图片瞬间，之前的识别结果框没有清空。
2. 图片识别后的文本框上的字体大小固定。
3. 文本框标签可能会超出图片边界。
4. 文本框背景半透明。
5. 置信度和主文本使用相同字体大小。

**解决方案**:
1. 添加了`clear_recognition_results`方法，并在切换模式、恢复相机、上传图片时调用。
2. 修改了`_draw_text_boxes`方法：
   - 文本框字体大小根据图片尺寸自动调整。
   - 添加边界检测逻辑。
   - 将文本背景改为纯白色。
   - 调整置信度字体大小和颜色。

**实施状态**: 已解决

### 12. 相机选择闪退

**问题描述**: 
在扫描摄像头后，从下拉列表中选择不同的摄像头会导致应用程序闪退。错误日志显示尝试访问已删除的 `QThread` 对象。

**解决方案**:
修改 `on_camera_selection_changed`，仅在摄像头运行时停止；修改 `stop_camera`，在停止线程后清除对 `camera_thread` 和 `camera_worker` 的引用。

**实施状态**: 已解决

## 已解决 / Closed Issues

*   **ISSUE-XXX: 比对逻辑未处理所有特殊符号 (例如逗号)**
    *   **状态:** 已解决 (Closed)
    *   **解决方案:** 更新了 `src/core/text_comparator.py` 中的 `_calculate_similarity` 方法，使用正则表达式 `re.sub(r'[^a-zA-Z0-9]', '', text)` 来过滤文本，只保留字母和数字进行比较。
